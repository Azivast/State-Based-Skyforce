Gameplay: 
https://sky-force-reloaded-2016.fandom.com/wiki/Game_Play
Sky Force Reloaded - [PC] Gameplay Part 1: https://www.youtube.com/watch?v=AK0yj1WVMJI


https://www.youtube.com/watch?v=NEvdyefORBo
https://www.youtube.com/watch?v=4FSeuQ7UjrM
https://www.youtube.com/watch?v=C09u4WoEufc&list=PLX2vGYjWbI0ROSj_B0_eir_VkHrEkd4pi&index=2
https://www.youtube.com/watch?v=AD4JIXQDw0s
Programming a BETTER state machine: https://www.youtube.com/watch?v=qsIiFsddGV4
Exempelprojekt från föreläsninngen: !!LÄNK HÄR!!
https://docs.unity3d.com/ScriptReference/Vector3.RotateTowards.html

Visual scripting:
Developing transitions using state graphs: https://docs.unity3d.com/Packages/com.unity.visualscripting@1.5/manual/vs-state.html
Changing states with transitions: https://docs.unity3d.com/Packages/com.unity.visualscripting@1.5/manual/vs-transitions.html

Sfx (cc0):
https://freesound.org/people/Exoticgaming/sounds/676638/
https://freesound.org/people/ajanhallinta/sounds/650701/
https://freesound.org/people/davidou/sounds/88467/
https://freesound.org/people/Nbs%20Dark/sounds/94185/
https://freesound.org/people/plasterbrain/sounds/464902/


Font: https://opengameart.org/content/kenney-fonts


- The dictionary approach severly restricts how State instances must be made. For one, they must be registered for every FSM when the FSM is initialized. Secondly, that also means they must be pre-defined which prevents dynamic adjustments to the state members. Thirdly, it expects a one-to-one mapping. This means a Walk vs Run state needs two separate enum values despite all the code behaviour being the exact same, only with the speed being the difference. Now imagine having a "slowedWalk", "boostedRun", "Sprint" and other variations. All of those could instead just be done during state construction, i.e.: "stateMachine.QueueNextState(new MoveState(moveSpeed))" where the moveSpeed could stay very dynamic throughout the game. There are other ways of passing movement speed but I think it serves as an example of flexible design.